
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>primer3plus.design &#8212; primer3plus 0.1.2 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for primer3plus.design</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;To run designs, you copy the underlying parameters and change certain
values.

There should be a number of presets available to run certain design
tasks  There should also be a relaxation parameter (a subclass of
Design?)  Async option  Design with overhangs
&quot;&quot;&quot;
import itertools
import re
import webbrowser
from collections import Counter
from functools import wraps
from typing import Dict
from typing import List
from typing import Tuple

import primer3

from .interfaces import ParameterAccessor
from .results import parse_primer3_results
from primer3plus.log import logger
from primer3plus.params import default_boulderio
from primer3plus.params import DOCURL


def _summarize_reasons(reasons):
    reason_dict = {}
    for reason in reasons:
        for k, v in reason.items():
            if &quot;EXPLAIN&quot; in k:
                for m in re.finditer(r&quot;\s*([\w\s\-]+)\s+(\d+)&quot;, v):
                    reason_token = m.group(1)
                    num = int(m.group(2))
                    reason_dict.setdefault(k, Counter())[reason_token] += num
    return {k: dict(v) for k, v in reason_dict.items()}


def combine_results(results):
    &quot;&quot;&quot;Combine and sort results. Combine all explainations.

    :param results: :type results: :return: :rtype:
    &quot;&quot;&quot;
    all_pairs = []
    all_reasons = []
    for r in results:
        all_pairs += list(r[0].values())
        all_reasons.append(r[1])
    sorted_pairs = sorted(all_pairs, key=lambda x: x[&quot;PAIR&quot;][&quot;PENALTY&quot;])
    explain = _summarize_reasons(all_reasons)
    return sorted_pairs, explain


def dispatch_iterable(params, max_results=10):
    &quot;&quot;&quot;Dispatches the function to combine and sorts results if an argument is
    an iterable indicated in `params`.

    e.g. `params = [(1, (type, list)]` will dispatch the function if the first argument
    is a list or tuple.
    &quot;&quot;&quot;

    def wrapped(f):
        @wraps(f)
        def _wrapped(*args, **kwargs):
            new_args = []
            is_iterable = False
            for pi, arg in enumerate(args):
                s = False
                for i, types in params:
                    if pi == i and type(arg) in types:
                        new_args.append(arg)
                        s = True
                        is_iterable = True
                if not s:
                    new_args.append([arg])
            if is_iterable:
                iterable_args = itertools.product(*new_args)
                results = []
                for _args in iterable_args:
                    if max_results &gt; 0 and len(results) &gt; max_results:
                        break
                    results.append(f(*_args, **kwargs))
                return combine_results(results)
            else:
                return f(*args, **kwargs)

        return _wrapped

    return wrapped


class DesignPresets:
    def __init__(self, design):
        self._design = design

    def _sequence_from_template(self, template, target):
        if isinstance(target, str):
            matches = self._get_index_of_match(template, target)
            if not matches:
                print(&quot;Target not in template&quot;)
                return None
            if len(matches) &gt; 1:
                print(&quot;More than one target found&quot;)
                return None
            return matches[0]

    def _get_index_of_match(self, template, sequence):
        matches = []
        for m in re.finditer(sequence, template, re.IGNORECASE):
            matches.append((m.start(0), m.end(0)))
        return matches

    def _set(self, update: dict):
        self._design.params.update(update)
        return self

    def task(self, task: str):
        &quot;&quot;&quot;This tag tells primer3 what task to perform. Legal values are:

        generic  Design a primer pair (the classic primer3 task) if the
        PRIMER_PICK_LEFT_PRIMER=1, and PRIMER_PICK_RIGHT_PRIMER=1. In addition, pick an
        internal hybridization oligo if PRIMER_PICK_INTERNAL_OLIGO=1.  NOTE: If
        PRIMER_PICK_LEFT_PRIMER=1, PRIMER_PICK_RIGHT_PRIMER=0 and
        PRIMER_PICK_INTERNAL_OLIGO=1, then behaves similarly to
        PRIMER_TASK=pick_primer_list.  pick_detection_primers  Deprecated alias for
        PRIMER_TASK=generic  check_primers  Primer3 only checks the primers provided in
        SEQUENCE_PRIMER, SEQUENCE_INTERNAL_OLIGO and SEQUENCE_PRIMER_REVCOMP. It is the
        only task that does not require a sequence. However, if SEQUENCE_TEMPLATE is
        provided, it is used. pick_primer_list  Pick all primers in SEQUENCE_TEMPLATE
        (possibly limited by SEQUENCE_INCLUDED_REGION, SEQUENCE_EXCLUDED_REGION,
        SEQUENCE_PRIMER_PAIR_OK_REGION_LIST, etc.). Returns the primers sorted by
        quality starting with the best primers. If PRIMER_PICK_LEFT_PRIMER and
        PRIMER_PICK_RIGHT_PRIMER is selected primer3 does not to pick primer pairs but
        generates independent lists of left primers, right primers, and, if requested,
        internal oligos.  pick_sequencing_primers  Pick primers suited to sequence a
        region. SEQUENCE_TARGET can be used to indicate several targets. The position of
        each primer is calculated for optimal sequencing results.  pick_cloning_primers
        Pick primers suited to clone a gene were the start nucleotide and the end
        nucleotide of the PCR fragment must be fixed, for example to clone an ORF.
        SEQUENCE_INCLUDED_REGION must be used to indicate the first and the last
        nucleotide. Due to these limitations primer3 can only vary the length of the
        primers. Set PRIMER_PICK_ANYWAY=1   to obtain primers even if they violate
        specific constraints.  pick_discriminative_primers  Pick primers suited to
        select primers which bind with their end at a specific position. This can be
        used to force the end of a primer to a polymorphic site, with the goal of
        discriminating between sequence variants. SEQUENCE_INCLUDED_REGION must be used
        to indicate the last nucleotide of the left (first nucleotide of included
        region) and the right primer (last nucleotide of included region). Due to these
        limitations primer3 can only vary the length of the primers. Set
        PRIMER_PICK_ANYWAY=1 to obtain primers even if they violate specific
        constraints. pick_pcr_primers  Deprecated shortcut for the following settings:
        PRIMER_TASK=generic PRIMER_PICK_LEFT_PRIMER=1 PRIMER_PICK_INTERNAL_OLIGO=0
        PRIMER_PICK_RIGHT_PRIMER=1  WARNING: this task changes the values of
        PRIMER_PICK_LEFT_PRIMER, PRIMER_PICK_INTERNAL_OLIGO, and
        PRIMER_PICK_RIGHT_PRIMER in a way that is not obvious by looking at the input.
        pick_pcr_primers_and_hyb_probe  Deprecated shortcut for the following settings:
        PRIMER_TASK=generic PRIMER_PICK_LEFT_PRIMER=1 PRIMER_PICK_INTERNAL_OLIGO=1
        PRIMER_PICK_RIGHT_PRIMER=1  WARNING: this task changes the values of
        PRIMER_PICK_LEFT_PRIMER, PRIMER_PICK_INTERNAL_OLIGO, and
        PRIMER_PICK_RIGHT_PRIMER in a way that is not obvious by looking at the input.
        pick_left_only  Deprecated shortcut for the following settings:
        PRIMER_TASK=generic PRIMER_PICK_LEFT_PRIMER=1 PRIMER_PICK_INTERNAL_OLIGO=0
        PRIMER_PICK_RIGHT_PRIMER=0  WARNING: this task changes the values of
        PRIMER_PICK_LEFT_PRIMER, PRIMER_PICK_INTERNAL_OLIGO, and
        PRIMER_PICK_RIGHT_PRIMER in a way that is not obvious by looking at the input.
        pick_right_only  Deprecated shortcut for the following settings:
        PRIMER_TASK=generic PRIMER_PICK_LEFT_PRIMER=0 PRIMER_PICK_INTERNAL_OLIGO=0
        PRIMER_PICK_RIGHT_PRIMER=1  WARNING: this task changes the values of
        PRIMER_PICK_LEFT_PRIMER, PRIMER_PICK_INTERNAL_OLIGO, and
        PRIMER_PICK_RIGHT_PRIMER in a way that is not obvious by looking at the input.
        pick_hyb_probe_only  Deprecated shortcut for the following settings:
        PRIMER_TASK=generic PRIMER_PICK_LEFT_PRIMER=0 PRIMER_PICK_INTERNAL_OLIGO=1
        PRIMER_PICK_RIGHT_PRIMER=0  WARNING: this task changes the values of
        PRIMER_PICK_LEFT_PRIMER, PRIMER_PICK_INTERNAL_OLIGO, and
        PRIMER_PICK_RIGHT_PRIMER in a way that is not obvious by looking at the input.
        :param task: :type task: :return: :rtype:
        &quot;&quot;&quot;
        self._set({&quot;PRIMER_TASK&quot;: task})
        return self

    def as_cloning_task(self):
        return self.task(&quot;pick_cloning_primers&quot;)

    def as_generic_task(self):
        return self.task(&quot;generic&quot;)

    def template(self, template):
        self._set({&quot;SEQUENCE_TEMPLATE&quot;: template})
        return self

    # TODO: set_iterations, set_num_return, set_force_return, set_gradient
    def primer_num_return(self, n):
        return self._set({&quot;PRIMER_NUM_RETURN&quot;: n})

    def product_size(self, interval: tuple, opt=None):
        &quot;&quot;&quot;Set the product size. Optionally include the optimal size.

        :param interval: a tuple of :type interval: :param opt: :type opt: :return:
        :rtype:
        &quot;&quot;&quot;
        if opt is None:
            opt = int(sum(interval) / 2.0)
        return self._set(
            {&quot;PRIMER_PRODUCT_SIZE_RANGE&quot;: interval, &quot;PRIMER_PRODUCT_OPT_SIZE&quot;: opt}
        )

    def pair_region_list(self, region_list: List[Tuple[int, int, int, int]]):
        return self._set({&quot;SEQUENCE_PRIMER_PAIR_OK_REGION_LIST&quot;: region_list})

    def left_sequence(self, primer: str):
        &quot;&quot;&quot;The sequence of a left primer to check and around which to design
        right primers and optional internal oligos. Must be a substring of
        SEQUENCE_TEMPLATE.

        :param primer: :type primer: :return: :rtype:
        &quot;&quot;&quot;
        return self._set({&quot;SEQUENCE_PRIMER&quot;: primer, &quot;PRIMER_PICK_RIGHT_PRIMER&quot;: 1})

    def right_sequence(self, primer: str):
        &quot;&quot;&quot;The sequence of a right primer to check and around which to design
        left primers and optional internal oligos. Must be a substring of the
        reverse strand of SEQUENCE_TEMPLATE.

        :param primer: :type primer: :return: :rtype:
        &quot;&quot;&quot;
        return self._set(
            {&quot;SEQUENCE_PRIMER_REVCOMP&quot;: primer, &quot;PRIMER_PICK_LEFT_PRIMER&quot;: 1}
        )

    def pick_left_only(self):
        return self._set({&quot;PRIMER_PICK_LEFT_PRIMER&quot;: 1, &quot;PRIMER_PICK_RIGHT_PRIMER&quot;: 0})

    def pick_right_only(self):
        return self._set({&quot;PRIMER_PICK_LEFT_PRIMER&quot;: 0, &quot;PRIMER_PICK_RIGHT_PRIMER&quot;: 1})

    def internal_sequence(self, primer: str):
        &quot;&quot;&quot;The sequence of an internal oligo to check and around which to
        design left and right primers. Must be a substring of
        SEQUENCE_TEMPLATE.

        :param primer: :type primer: :return: :rtype:
        &quot;&quot;&quot;
        self._set({&quot;SEQUENCE_INTERNAL_OLIGO&quot;: primer, &quot;PRIMER_PICK_INTERNAL_OLIGO&quot;: 1})

    def primers(self, p1: str, p2: str):
        if p1:
            self.left_sequence(p1)
        if p2:
            self.right_sequence(p2)
        return self

    def included(self, interval: tuple):
        &quot;&quot;&quot;A sub-region of the given sequence in which to pick primers. For
        example, often the first dozen or so bases of a sequence are vector,
        and should be excluded from consideration. The value for this parameter
        has the form.

        &lt;start&gt;,&lt;length&gt; where &lt;start&gt; is the index of the first base to consider, and
        &lt;length&gt; is the number of subsequent bases in the primer-picking region.  :param
        interval: :type interval: :return: :rtype:
        &quot;&quot;&quot;
        return self._set({&quot;SEQUENCE_INCLUDED_REGION&quot;: interval})

    def target(self, interval: tuple):
        &quot;&quot;&quot;If one or more targets is specified then a legal primer pair must
        flank at least one of them. A target might be a simple sequence repeat
        site (for example a CA repeat) or a single-base-pair polymorphism, or
        an exon for resequencing. The value should be a space-separated list
        of.

        &lt;start&gt;,&lt;length&gt; pairs where &lt;start&gt; is the index of the first base of a target,
        and &lt;length&gt; is its length.  See also PRIMER_INSIDE_PENALTY,
        PRIMER_OUTSIDE_PENALTY. Has a different meaning when
        PRIMER_TASK=pick_sequencing_primers. See PRIMER_TASK for more information.
        :param interval: :type interval: :return: :rtype:
        &quot;&quot;&quot;
        if isinstance(interval, str):
            interval = self._sequence_from_template(
                self._design.params[&quot;SEQUENCE_TEMPLATE&quot;], interval
            )
        return self._set({&quot;SEQUENCE_TARGET&quot;: interval})

    def excluded(self, interval):
        &quot;&quot;&quot;Primers and oligos may not overlap any region specified in this tag.
        The associated value must be a space-separated list of.

        &lt;start&gt;,&lt;length&gt; pairs where &lt;start&gt; is the index of the first base of the
        excluded region, and &lt;length&gt; is its length. This tag is useful for tasks such
        as excluding regions of low sequence quality or for excluding regions containing
        repetitive elements such as ALUs or LINEs.  :param interval: :type interval:
        :return: :rtype:
        &quot;&quot;&quot;
        if isinstance(interval, str):
            interval = self._sequence_from_template(
                self._design.params[&quot;SEQUENCE_TEMPLATE&quot;], interval
            )
        return self._set({&quot;SEQUENCE_EXCLUDED_REGION&quot;: interval})

    def pick_anyway(self, b=1):
        &quot;&quot;&quot;If true use primer provided in SEQUENCE_PRIMER,
        SEQUENCE_PRIMER_REVCOMP, or SEQUENCE_INTERNAL_OLIGO even if it violates
        specific constraints.

        :param b: :type b: :return: :rtype:
        &quot;&quot;&quot;
        return self._set({&quot;PRIMER_PICK_ANYWAY&quot;: b})


def clip(x, mn, mx):
    return max(min(x, mx), mn)


class DesignBase:

    DEFAULT_PARAMS = default_boulderio()
    DEFAULT_GRADIENT = dict(
        PRIMER_MAX_SIZE=(1, DEFAULT_PARAMS[&quot;PRIMER_MAX_SIZE&quot;], 36),
        PRIMER_MIN_SIZE=(-1, 16, DEFAULT_PARAMS[&quot;PRIMER_MAX_SIZE&quot;]),
        PRIMER_MAX_TM=(1, DEFAULT_PARAMS[&quot;PRIMER_MAX_SIZE&quot;], 80),
        PRIMER_MIN_TM=(-1, 48, DEFAULT_PARAMS[&quot;PRIMER_MIN_TM&quot;]),
        PRIMER_MAX_HAIRPIN_TH=(1, DEFAULT_PARAMS[&quot;PRIMER_MAX_HAIRPIN_TH&quot;], 60),
    )  # the default gradient to use for the :meth:`run_and_optimize` method.
    CHECK_PRIMERS = &quot;check_primers&quot;
    GENERIC = &quot;generic&quot;
    PICK_PRIMER_LIST = &quot;pick_primer_list&quot;
    PICK_SEQUENCING_PRIMERS = &quot;pick_sequencing_primers&quot;
    PICK_CLONING_PRIMERS = &quot;pick_cloning_primers&quot;
    PICK_DISCRIMINATIVE_PRIMERS = &quot;pick_discriminative_primers&quot;

    def __init__(self):
        self.params = self.DEFAULT_PARAMS.copy()
        self.logger = logger(self)

    def run(self, params=None) -&gt; Tuple[List[Dict], List[Dict]]:
        &quot;&quot;&quot;
        Design primers. Optionally provide additional parameters.

        :param params:
        :return:
        &quot;&quot;&quot;
        if params is None:
            params = self.params
        results = primer3.bindings.designPrimers(params.sequence(), params.globals())
        pairs, explain = parse_primer3_results(results)
        return pairs, explain

    def run_and_optimize(self, max_iterations, params=None, gradient=DEFAULT_GRADIENT) -&gt; Tuple[dict, dict]:
        &quot;&quot;&quot;
        Design primers. If primer design is unsuccessful, relax parameters as defined
        in Design.DEFAULT_GRADIENT. Repeat for the specified number of max_iterations.

        :param max_iterations: the max number of iterations to perform relaxation
        :param params: optional parameters to provide
        :param gradient: optional gradient to provide. If not provided, Design.DEFAULT_GRADIENT will be used.
        :return:
        &quot;&quot;&quot;
        if params is None:
            params = self.params
        # n_return = params[&quot;PRIMER_NUM_RETURN&quot;]
        pairs, explain = self.run(params)
        i = 0
        while i &lt; max_iterations and len(pairs) == 0:
            i += 1
            update = self._update_dict(params, gradient=gradient)
            if update:
                self.logger.info(&quot;Updated: {}&quot;.format(update))
            else:
                break
            self.params.update(update)
            pairs, explain = self.run(params)
        return pairs, explain

    @staticmethod
    def _update_dict(params, gradient):
        update = {}
        for param_key, gradient_tuple in gradient.items():
            delta, mn, mx = gradient_tuple
            try:
                val = params[param_key] + delta
                val = clip(val, mn, mx)
                if params[param_key] != val:
                    update[param_key] = val
            except Exception as e:
                raise e
        return update

    @staticmethod
    def open_help():
        &quot;&quot;&quot;Open the documentation help in a new browser tab.&quot;&quot;&quot;
        webbrowser.open(DOCURL)

    def copy(self):
        &quot;&quot;&quot;Copy this design and its parameters.&quot;&quot;&quot;
        designer = self.__class__()
        designer.params = self.params.copy()

    def __copy__(self):
        return self.copy()


<div class="viewcode-block" id="Design"><a class="viewcode-back" href="../../developer/_autosummary/primer3plus.Design.html#primer3plus.Design">[docs]</a>class Design(DesignBase):
    &quot;&quot;&quot;Primer design module.&quot;&quot;&quot;
    P = ParameterAccessor()

<div class="viewcode-block" id="Design.__init__"><a class="viewcode-back" href="../../developer/_autosummary/primer3plus.Design.html#primer3plus.Design.__init__">[docs]</a>    def __init__(self, **kwargs):
        &quot;&quot;&quot;Initialize a new design. Set parameters using :meth:`set` as in:

        .. code-block::

            design = Design()
            design.set.template(&quot;AGGCTGTAGTGCTTGTAGCTGGTTGCGTTACTGTG&quot;)
            # and so one
        &quot;&quot;&quot;
        super().__init__(**kwargs)
        self.set = DesignPresets(self)</div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">primer3plus</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/api_reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017-2019, University of Washington.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>